// Generated by CoffeeScript 1.6.3
(function() {
  var AbstractLogger;

  module.exports = AbstractLogger = (function() {
    'use strict';
    var Config, DEFAULT_FORMAT_PATTERN, DEFAULT_LOG_LEVEL, KEYS_FORMAT_PATTERN, KEYS_LEVELS, LogLevels, SortedLogLevels, n, pad, parseLevelConfig, rpad, v, _LogLevels;

    _LogLevels = require('../util/LogLevels');

    Config = require('../util/Config');

    LogLevels = (function() {
      var l, n, v;
      l = {};
      for (n in _LogLevels) {
        v = _LogLevels[n];
        l[n.toLowerCase()] = v;
      }
      return l;
    })();

    SortedLogLevels = ((function() {
      var _results;
      _results = [];
      for (n in LogLevels) {
        v = LogLevels[n];
        _results.push({
          n: n,
          v: v
        });
      }
      return _results;
    })()).sort(function(a, b) {
      return a.v - b.v;
    }).map(function(a) {
      return a.n;
    });

    DEFAULT_LOG_LEVEL = 'INFO';

    DEFAULT_FORMAT_PATTERN = '%{DATETIME} %L  %n: %m';

    KEYS_FORMAT_PATTERN = ['formatPattern', 'format', 'pattern'];

    KEYS_LEVELS = ['levels', 'level'];

    parseLevelConfig = function(config) {
      var L, fnd, levels, levelset, lvl, max, min, name, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      levelset = {};
      levels = Config.extend({
        '': DEFAULT_LOG_LEVEL
      }, (_ref = config.getOption.apply(config, KEYS_LEVELS)) != null ? _ref : {});
      min = (_ref1 = LogLevels[(_ref2 = config.getOption('minLevel', 'min')) != null ? _ref2.toLowerCase() : void 0]) != null ? _ref1 : 0;
      max = (_ref3 = LogLevels[(_ref4 = config.getOption('maxLevel', 'max')) != null ? _ref4.toLowerCase() : void 0]) != null ? _ref3 : Number.POSITIVE_INFINITY;
      if (min > max) {
        _ref5 = [min, max], max = _ref5[0], min = _ref5[1];
      }
      for (name in levels) {
        lvl = levels[name];
        if (typeof lvl === 'string') {
          lvl = lvl.toLowerCase();
          switch (false) {
            case lvl !== 'off':
              n = [];
              break;
            case lvl !== 'all':
              n = SortedLogLevels;
              break;
            case !(lvl in LogLevels):
              n = [];
              fnd = false;
              for (_i = 0, _len = SortedLogLevels.length; _i < _len; _i++) {
                L = SortedLogLevels[_i];
                if (L === lvl) {
                  fnd = true;
                }
                if (fnd) {
                  n.push(L);
                }
              }
              break;
            default:
              continue;
          }
        } else {
          n = [].map.call(lvl, function(x) {
            return x.toLowerCase();
          }).filter(function(x) {
            return x in LogLevels;
          });
        }
        levelset[name.trim()] = _LogLevels.combine.apply(_LogLevels, n.map(function(x) {
          return LogLevels[x];
        }).filter(function(x) {
          return (min <= x && x <= max);
        }));
      }
      return levelset;
    };

    function AbstractLogger(config) {
      var _ref;
      this.levelConfig = parseLevelConfig(config);
      this.formatPattern = ("" + ((_ref = config.getOption.apply(config, KEYS_FORMAT_PATTERN)) != null ? _ref : DEFAULT_FORMAT_PATTERN)).replace(/%\{(\w*)\}/g, function(_, code) {
        switch (code.toUpperCase()) {
          case 'DATETIME':
            return '%Y-%M-%D %H:%i:%s.%S';
          case 'DATETIME_ISO8601':
            return '%Y-%M-%DT%H:%i:%s.%S';
          case 'DATE':
            return '%Y-%M-%D';
          case 'TIME':
            return '%H:%i:%s.%S';
          default:
            return '';
        }
      });
    }

    AbstractLogger.prototype.getLevelConfig = function(parts) {
      var len, lvlcfg, testname;
      len = parts.length;
      lvlcfg = this.levelConfig;
      while (len >= 0) {
        testname = parts.slice(0, len--).join('.');
        if (testname in lvlcfg) {
          return {
            mask: lvlcfg[testname]
          };
        }
      }
      throw new Error('Invalid internal level config');
    };

    pad = function(s, n) {
      if (n == null) {
        n = 2;
      }
      s = "" + s;
      while (s.length < n) {
        s = "0" + s;
      }
      return s;
    };

    rpad = function(s, n) {
      s = "" + s;
      while (s.length < n) {
        s += ' ';
      }
      return s;
    };

    AbstractLogger.prototype.formatLogMessage = function(obj) {
      return this.formatPattern.replace(/%(\d+)?([mnLDMYHisST%])/g, function(_, cnt, optchar) {
        if (cnt != null) {
          cnt = parseInt(cnt, 10);
        }
        switch (optchar) {
          case 'm':
            return obj.msg;
          case 'n':
            if (cnt != null) {
              return obj.parts.slice(-1 - cnt).join('.');
            } else {
              return obj.name;
            }
            break;
          case 'L':
            return rpad(obj.level.toUpperCase(), cnt != null ? cnt : 5);
          case 'D':
            return pad(obj.date.getDate(), cnt);
          case 'M':
            return pad(1 + obj.date.getMonth(), cnt);
          case 'Y':
            return pad(obj.date.getFullYear(), cnt != null ? cnt : 0);
          case 'H':
            return pad(obj.date.getHours(), cnt);
          case 'i':
            return pad(obj.date.getMinutes(), cnt);
          case 's':
            return pad(obj.date.getSeconds(), cnt);
          case 'S':
            return pad(obj.date.getMilliseconds(), cnt != null ? cnt : 3);
          case 'T':
            return pad(obj.date.getTime(), cnt != null ? cnt : 0);
          case '%':
            return '%';
          default:
            return '';
        }
      });
    };

    AbstractLogger.prototype.logMessage = function(obj) {
      return this.log(this.formatLogMessage(obj));
    };

    return AbstractLogger;

  })();

}).call(this);
