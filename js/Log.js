// Generated by CoffeeScript 1.6.3
(function() {
  var Log,
    __slice = [].slice;

  module.exports = Log = (function() {
    'use strict';
    var DEFAULT_LOGCONFIG, LogLevels, Logger, buildLogMessage, defineProperty, getLogger,
      _this = this;

    LogLevels = require('./util/LogLevels');

    defineProperty = Object.defineProperty;

    DEFAULT_LOGCONFIG = 'logconf.json';

    Logger = null;

    Log.setLogger = function(logger) {
      if (logger == null) {
        logger = DEFAULT_LOGCONFIG;
      }
      if (typeof logger === 'string') {
        logger = require('./util/LogAutoConfigurer').findAndConfigureLogging(logger);
      }
      if ((logger == null) || typeof logger.getLevelConfig !== 'function' || typeof logger.logMessage !== 'function') {
        throw new Error('Logger not usable');
      }
      Logger = logger;
    };

    getLogger = function() {
      if (Logger == null) {
        Log.setLogger();
      }
      return Logger;
    };

    buildLogMessage = function(msg, args, callback) {
      var i;
      if (typeof msg === 'function') {
        if (msg.length) {
          msg(function(asyncLogMessage) {
            return callback(asyncLogMessage);
          });
        } else {
          callback(msg());
        }
      } else {
        i = 0;
        callback(("" + msg).replace(/\{(\d*)\}/g, function(_, idx) {
          return args[idx ? parseInt(idx, 10) : i++];
        }));
      }
    };

    function Log(name) {
      var extra, level, levelname, logger, mask, nameParts, _fn, _ref,
        _this = this;
      if (typeof name !== 'string' || !(name = name.trim())) {
        throw new Error('Logger name required');
      }
      nameParts = name.split(/\./);
      if (!nameParts.every(function(p) {
        return p;
      })) {
        throw new Error("Invalid logger name: " + name);
      }
      defineProperty(this, 'name', {
        enumerable: true,
        get: function() {
          return name;
        }
      });
      logger = getLogger();
      _ref = logger.getLevelConfig(nameParts), mask = _ref.mask, extra = _ref.extra;
      _fn = function(levelname, level) {
        var granted, logfunc;
        granted = !!LogLevels.isset(mask, level);
        logfunc = granted ? function() {
          var args, msg;
          msg = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          return buildLogMessage(msg, args, function(logMessage) {
            return logger.logMessage({
              level: levelname,
              numLevel: level,
              msg: logMessage,
              name: name,
              parts: nameParts,
              extra: extra,
              date: new Date()
            });
          });
        } : function() {};
        defineProperty(_this, "is" + levelname, {
          configurable: true,
          enumerable: false,
          writable: false,
          value: granted ? function() {
            return true;
          } : function() {
            return false;
          }
        });
        return defineProperty(_this, levelname.toLowerCase(), {
          configurable: true,
          enumerable: false,
          writable: false,
          value: logfunc
        });
      };
      for (levelname in LogLevels) {
        level = LogLevels[levelname];
        _fn(levelname, level);
      }
    }

    Log.prototype.toString = function() {
      return "Logger " + this.name;
    };

    return Log;

  }).call(this);

}).call(this);
