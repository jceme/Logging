// Generated by CoffeeScript 1.3.3
(function() {
  var AdapterMock, Log, TeeAdapter, should;

  AdapterMock = (function() {

    function AdapterMock() {}

    "fatal error warn info debug trace".split(' ').forEach(function(key) {
      return AdapterMock.prototype[key] = function(msg) {
        this.lastLevel = key;
        return this.lastMessage = msg;
      };
    });

    AdapterMock.prototype.assert = function(level, msg) {
      this.lastLevel.should.equal(level, 'Mock level check');
      return this.lastMessage.should.equal(msg, 'Mock message check');
    };

    AdapterMock.prototype.reset = function() {
      delete this.lastLevel;
      return delete this.lastMessage;
    };

    return AdapterMock;

  })();

  Log = require('../Log');

  TeeAdapter = require('../adapters/TeeAdapter');

  should = require('should');

  suite('Sole logging', function() {
    test('Log available', function() {
      Log.should.be.a('function');
      Log.DEFAULT_LEVEL.should.be.a('number');
      Log.DEFAULT_ADAPTER.should.be.ok;
      return Log.Level.should.be.a('object');
    });
    return test('Log creatable', function() {
      (new Log("foo")).should.be.ok;
      (new Log("bar", Log.Level.DEBUG)).should.be.ok;
      (new Log("bar", Log.Level.DEBUG, {})).should.be.ok;
      (function() {
        return new Log();
      }).should["throw"]();
      (function() {
        return new Log(null);
      }).should["throw"]();
      return (function() {
        return new Log("");
      }).should["throw"]();
    });
  });

  suite('Logging', function() {
    var defadapter, deflevel, mock;
    mock = null;
    deflevel = Log.DEFAULT_LEVEL;
    defadapter = Log.DEFAULT_ADAPTER;
    setup(function() {
      return mock = new AdapterMock();
    });
    teardown(function() {
      Log.DEFAULT_LEVEL = deflevel;
      return Log.DEFAULT_ADAPTER = defadapter;
    });
    test('Log output', function() {
      var log;
      should.exist(Log.Level.ALL, 'Class has level ALL');
      Log.DEFAULT_LEVEL = Log.Level.ALL;
      log = new Log("testlogger", Log.Level.ALL, mock);
      log.fatal('This is a fatal message');
      mock.assert('fatal', '[FATAL] testlogger: This is a fatal message');
      log.error('This is a error message');
      mock.assert('error', '[ERROR] testlogger: This is a error message');
      log.warn('This is a warn message');
      mock.assert('warn', '[WARN] testlogger: This is a warn message');
      log.info('This is a info message');
      mock.assert('info', '[INFO] testlogger: This is a info message');
      log.debug('This is a debug message');
      mock.assert('debug', '[DEBUG] testlogger: This is a debug message');
      log.trace('This is a trace message');
      return mock.assert('trace', '[TRACE] testlogger: This is a trace message');
    });
    test('Levels', function() {
      var log;
      log = new Log("my test logger", Log.Level.WARN, mock);
      mock.reset();
      log.info("msg");
      should.not.exist(mock.lastMessage);
      mock.reset();
      log.warn("msg");
      should.exist(mock.lastMessage);
      mock.reset();
      log.debug("msg");
      should.not.exist(mock.lastMessage);
      mock.reset();
      log.error("msg");
      should.exist(mock.lastMessage);
      mock.reset();
      log.fatal("msg");
      should.exist(mock.lastMessage);
      log.level = Log.Level.ALL;
      mock.reset();
      log.trace("msg");
      should.exist(mock.lastMessage);
      mock.reset();
      log.info("msg");
      should.exist(mock.lastMessage);
      mock.reset();
      log.fatal("msg");
      should.exist(mock.lastMessage);
      log.level = Log.Level.OFF;
      mock.reset();
      log.trace("msg");
      should.not.exist(mock.lastMessage);
      mock.reset();
      log.info("msg");
      should.not.exist(mock.lastMessage);
      mock.reset();
      log.fatal("msg");
      return should.not.exist(mock.lastMessage);
    });
    test('Level fallback', function() {
      var log;
      Log.DEFAULT_LEVEL = Log.Level.ERROR;
      log = new Log("testlogger", null, mock);
      log.level.should.equal(Log.Level.ERROR);
      Log.DEFAULT_LEVEL = Log.Level.INFO;
      log = new Log("testlogger", null, mock);
      log.level.should.equal(Log.Level.INFO);
      mock.reset();
      log.info("msg");
      should.exist(mock.lastMessage);
      mock.reset();
      log.debug("msg");
      should.not.exist(mock.lastMessage);
      mock.reset();
      log.trace("msg");
      should.not.exist(mock.lastMessage);
      log.level = Log.Level.DEBUG;
      Log.DEFAULT_LEVEL.should.equal(Log.Level.INFO);
      mock.reset();
      log.info("msg");
      should.exist(mock.lastMessage);
      mock.reset();
      log.debug("msg");
      should.exist(mock.lastMessage);
      mock.reset();
      log.trace("msg");
      return should.not.exist(mock.lastMessage);
    });
    test('Log messages', function() {
      var executed, log;
      log = new Log("testlogger", Log.Level.DEBUG, mock);
      mock.reset();
      log.debug('My normal log message');
      mock.assert('debug', '[DEBUG] testlogger: My normal log message');
      mock.reset();
      log.trace('My normal log message');
      should.not.exist(mock.lastMessage);
      mock.reset();
      log.warn('My {} param log message with {} and {} params', 'foo bar', true);
      mock.assert('warn', '[WARN] testlogger: My foo bar param log message with true and undefined params');
      mock.reset();
      log.trace('My {} param log message with {} and {} params', 'foo bar', true);
      should.not.exist(mock.lastMessage);
      mock.reset();
      log.info('My {1} param with {0} before', 42, true);
      mock.assert('info', '[INFO] testlogger: My true param with 42 before');
      mock.reset();
      log.info('My {} param with {2} last and {} next', 42, true, 'bar');
      mock.assert('info', '[INFO] testlogger: My 42 param with bar last and true next');
      mock.reset();
      log.error(function() {
        return JSON.stringify({
          foo: "bar"
        });
      });
      mock.assert('error', '[ERROR] testlogger: {"foo":"bar"}');
      mock.reset();
      executed = false;
      log.trace(function() {
        executed = true;
        return 'foo';
      });
      should.not.exist(mock.lastMessage);
      return executed.should.be["false"];
    });
    test('Asynchronous log messages', function(done) {
      var log;
      log = new Log("testlogger", Log.Level.DEBUG, mock);
      mock.reset();
      log.debug(function(innerdone) {
        return setTimeout(function() {
          innerdone('Async log message');
          mock.assert('debug', '[DEBUG] testlogger: Async log message');
          return done();
        }, 20);
      });
      return should.not.exist(mock.lastMessage);
    });
    return test('Tee test setup', function() {
      var adapter, log, mock1, mock2;
      mock1 = new AdapterMock();
      mock2 = new AdapterMock();
      adapter = new TeeAdapter(mock1, new TeeAdapter(mock2));
      log = new Log("testlogger", Log.Level.DEBUG, adapter);
      should.not.exist(mock1.lastMessage);
      should.not.exist(mock2.lastMessage);
      log.info('Count of mocks: {}', 2);
      mock1.assert('info', '[INFO] testlogger: Count of mocks: 2');
      return mock2.assert('info', '[INFO] testlogger: Count of mocks: 2');
    });
  });

}).call(this);
